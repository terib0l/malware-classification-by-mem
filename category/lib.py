import glob
import numpy as np
import tensorflow as tf
from enum import IntEnum, Enum
from typing import List
from sklearn.model_selection import train_test_split

CATEGORY_LABELS = [
    "Adposhel", "Allaple", "Amonetize", "AutoRun",
    "BrowseFox", "Dinwod", "InstallCore", "MultiPlug",
    "Other", "VBA", "Vilsel"
]
BINARY_LABELS = ["Malware", "Benign"]

class LabelsNum(IntEnum):
    binary = 2
    category = 11

class PretrainedModel(str, Enum):
    VGG16 = "vgg16"
    VGG19 = "vgg19"
    RESNET50 = "resnet50"
    XCEPTION = "xception"
    INCEPTION_V3 = "inception_v3"
    MOBILENET_V3 = "mobilenet_v3"

class DumpwarePreparation:
    def __init__(
            self,
            data_dir: list = [
                '/content/4096/300/TRAIN/',
                '/content/4096/300/TEST/'
            ],
            labels_num: LabelsNum = LabelsNum.category,
            model_name: PretrainedModel = PretrainedModel.VGG16
        ):
        self.data_dir = data_dir
        self.labels_num = labels_num
        self.model_name = model_name
        self.x_train = None
        self.x_test = None
        self.y_train = None
        self.y_test = None

    def preprocess_func(self) -> function:
        if self.model_name == "vgg19":
            return tf.keras.applications.vgg19.preprocess_input
        elif self.model_name == "resnet50":
            return tf.keras.applications.resnet50.preprocess_input
        elif self.model_name == "xception":
            return tf.keras.applications.xception.preprocess_input
        elif self.model_name == "inception_v3":
            return tf.keras.applications.inception_v3.preprocess_input
        elif self.model_name == "mobilenet_v3":
            return tf.keras.applications.mobilenet_v3.preprocess_input

        # self.model_name == "vgg16"
        return tf.keras.applications.vgg16.preprocess_input
            

    def prepare_dumpware10_for_category(self):
        temp_x = []
        temp_y = []

        for dir_path in self.data_dir:
            for label_num, label in enumerate(CATEGORY_LABELS):
                label_dir_path = dir_path + label
                png_paths = glob.glob(label_dir_path + "/*.png")

                for png_path in png_paths:
                    png = tf.keras.preprocessing.image.load_img(
                        path=png_path,
                        color_mode='rgb',
                        target_size=(256, 256),
                        interpolation='bicubic'
                    )
                    png = tf.keras.preprocessing.image.img_to_array(png)
                    png = self.preprocess_func()(png)

                    temp_x.append(png)
                    temp_y.append(label_num)

        temp_x = np.array(temp_x) / 255
        temp_y = np.array(temp_y)

        self.x_train, self.x_test, self.y_train, self.y_test = \
        train_test_split(temp_x, temp_y, test_size=0.2, shuffle=True)

        del temp_x, temp_y

        return self.x_train, self.x_test, self.y_train, self.y_test

    def prepare_dumpware10_for_binary(self):
        pass

    def _summary(self) -> None:
        print(f"x_train: {self.x_train.shape}")
        print(f"y_train: {self.y_train.shape}")
        print(f"x_test: {self.x_test.shape}")
        print(f"y_test: {self.y_test.shape}")

def output_metrix_from_matrix(matrix: List[List[int]], labels_num: LabelsNum):
    TP = []
    FP = []
    TN = []
    FN = []

    for k in range(labels_num):
        fp = 0
        fn = 0
        tn = 0
        for i in range(labels_num):
            for j in range(labels_num):
                if k == i and k == j:
                    TP.append(matrix[i][j])
                elif k == i and k != j:
                    fp += matrix[i][j]
                elif k != i and k == j:
                    fn += matrix[i][j]
                else:
                    tn += matrix[i][j]
        FP.append(fp)
        FN.append(fn)
        TN.append(tn)

    TPs = sum(TP)
    accuracy = TPs / sum(list(map(sum, zip(*matrix))))

    precision = list()
    for i in range(labels_num):
      precision.append(TP[i] / (TP[i] + FP[i]))

    recall = list()
    for i in range(labels_num):
      recall.append(TP[i] / (TP[i] + FN[i]))

    f1_score = list()
    for i in range(labels_num):
      f1_score.append((2 * precision[i] * recall[i]) / (precision[i] + recall[i]))

    fpr = list()
    for i in range(labels_num):
      fpr.append(FP[i] / (FP[i] + TN[i]))

    print('Accuracy: ', accuracy)
    print('Precision: ', np.nansum(precision) / labels_num)
    print('Recall: ', np.nansum(recall) / labels_num)
    print('F1-Score: ', np.nansum(f1_score) / labels_num)
    print('FPR: ', np.nansum(fpr) / labels_num)
