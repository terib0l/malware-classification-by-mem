import tensorflow as tf
from xgboost import XGBClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from module.schema import PretrainedModel, ClassifyModel, CaseLabel

class BasicModel:
    def __init__(
        self,
        x_train,
        y_train,
        x_test,
        convolutional_model: PretrainedModel = PretrainedModel.VGG16,
        classify_func: ClassifyModel = ClassifyModel.FCN,
        problem_case: CaseLabel = CaseLabel.CATEGORY
    ):
        self.x_train=x_train
        self.y_train=y_train
        self.x_test=x_test
        self.convolutional_model = convolutional_model
        self.classify_func = classify_func
        self.problem_case = problem_case


    def flow_execute(self):
        # only fcn
        if self.classify_func == "fcn":
            if self.problem_case == CaseLabel.CATEGORY:
                print("""
                        FCN - Category Case
                """)
                return self.category_case_basic_flow()
            elif self.problem_case == CaseLabel.BINARY:
                print("""
                        FCN - Binary Case
                """)
                return self.binary_case_basic_flow()
            else:
                raise NotImplementedError
        # others (svm, rf, knn, j48, xgboost)
        else:
            if self.problem_case == CaseLabel.CATEGORY:
                print("""
                        Transfer+ML - Category Case
                """)
            else:
                print("""
                        Transfer+ML - Binary Case
                """)

            return self.transfer_flow()


    def choose_convolutional_model(self):
        if self.convolutional_model == "vgg16":
            print("""
                    VGG16
            """)
            base_model = tf.keras.applications.VGG16(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "vgg19":
            print("""
                    VGG19
            """)
            base_model = tf.keras.applications.VGG19(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "resnet152":
            print("""
                    ResNet152
            """)
            base_model = tf.keras.applications.ResNet152(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "densenet201":
            print("""
                    DenseNet201
            """)
            base_model = tf.keras.applications.DenseNet201(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "xception":
            print("""
                    Xception
            """)
            base_model = tf.keras.applications.Xception(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "inception_v3":
            print("""
                    InceptionV3
            """)
            base_model = tf.keras.applications.InceptionV3(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "small_mobilenet_v3":
            print("""
                    MobileNetV3 Small
            """)
            base_model = tf.keras.applications.MobileNetV3Small(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        elif self.convolutional_model == "large_mobilenet_v3":
            print("""
                    MobileNetV3 Large
            """)
            base_model = tf.keras.applications.MobileNetV3Large(
                weights='imagenet',
                include_top=False,
                input_shape=(256, 256, 3)
            )

        else:
            raise Exception("No Pretrained Model")

        base_model.trainable=False

        return base_model


    def binary_case_basic_flow(self):
        base_model = self.choose_convolutional_model()

        model = tf.keras.models.Sequential()
        model.add(base_model)
        model.add(tf.keras.layers.Flatten())
        model.add(tf.keras.layers.Dense(64, activation='relu'))
        model.add(tf.keras.layers.Dense(1, activation='sigmoid'))
        model.summary()

        model.compile(
            optimizer='adam',
            loss='binary_crossentropy',
            metrics=[
                tf.keras.metrics.BinaryAccuracy(name='accuracy'),
                tf.keras.metrics.Precision(name='precision'),
                tf.keras.metrics.Recall(name='recall'),
            ]
        )

        model.fit(
            x=self.x_train,
            y=self.y_train,
            batch_size=32,
            epochs=50,
            callbacks=[
                tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
            ],
            verbose='auto'
        )

        return model


    def category_case_basic_flow(self):
        base_model = self.choose_convolutional_model()

        model = tf.keras.models.Sequential()
        model.add(base_model)
        model.add(tf.keras.layers.Flatten())
        model.add(tf.keras.layers.Dense(64, activation='relu'))
        model.add(tf.keras.layers.Dense(11, activation='softmax'))
        model.summary()

        model.compile(
            optimizer='adam',
            loss='sparse_categorical_crossentropy',
            metrics=['accuracy']
        )

        model.fit(
            x=self.x_train,
            y=self.y_train,
            batch_size=32,
            epochs=50,
            callbacks=[
                tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
            ],
            verbose='auto'
        )
        y_pred = model.predict(self.x_test).argmax(axis=1)

        return y_pred


    def choose_ml_classifier(self):
        if self.classify_func == "svm":
            print("""
                    SVM
            """)
            clf = SVC(
                kernel = "rbf",
                # C = 10,
                # gamma = 'scale',
            )

        elif self.classify_func == "rf":
            print("""
                    RF
            """)
            clf = RandomForestClassifier(
                # n_estimators = ,
                # max_features = ,
                # max_depth = ,
                criterion="gini",
                min_samples_leaf=1,
                random_state=0,
            )

        elif self.classify_func == "knn":
            print("""
                    KNN
            """)
            clf = KNeighborsClassifier(
                # n_neighbors = ,
                # weights = ,
                # metric = ,
            )

        elif self.classify_func == "j48":
            print("""
                    J48
            """)
            clf = DecisionTreeClassifier(
                # max_features = ,
                # ccp_alpha = ,
                # max_depth = ,
                # criterion = ,
            )

        elif self.classify_func == "xgboost":
            print("""
                    XGBOOST
            """)
            clf = XGBClassifier(
                # max_depth = ,
                # n_estimators = ,
            )

        elif self.classify_func == "test":
            print("""
                    TEST
            """)
            # kernel = {linear, poly, rbf, sigmoid, precomputed}
            clf = SVC(kernel = "linear", C = 100, gamma = 0.01)

        else:
            raise Exception("No Clf Model")

        return clf


    def transfer_flow(self):
        base_model = self.choose_convolutional_model()

        bf_train = base_model.predict(self.x_train)
        bf_train = bf_train.reshape(bf_train.shape[0], -1)
        bf_test = base_model.predict(self.x_test)
        bf_test = bf_test.reshape(bf_test.shape[0], -1)
        print("\nBottleneck Features:\nbf_train: {}\nbf_test: {}\n".format(bf_train.shape, bf_test.shape))

        clf = self.choose_ml_classifier()

        clf.fit(bf_train, self.y_train)
        y_pred = clf.predict(bf_test)

        del bf_train, bf_test

        return y_pred

