import tensorflow as tf
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Dropout, Input, Conv2D, multiply, LocallyConnected2D, Lambda, BatchNormalization
from tensorflow.keras.models import Model
from model.basic import BasicModel
from module.schema import CaseLabel


class BottleNeck(BasicModel):
    def binary_case_basic_flow(self):
        conv_base = self.choose_convolutional_model()

        model = dynamic_spatial_module(conv_base, self.problem_case)
        model.summary()

        model.compile(
            # optimizer='adam',
            optimizer = tf.keras.optimizers.RMSprop(
                learning_rate=1e-5,
                # learning_rate=0.001, rho=0.9, epsilon=None, decay=0.0
            ),
            loss='binary_crossentropy',
            metrics=[
                tf.keras.metrics.BinaryAccuracy(name='accuracy'),
                tf.keras.metrics.Precision(name='precision'),
                tf.keras.metrics.Recall(name='recall'),
            ]
        )

        model.fit(
            x=self.x_train,
            y=self.y_train,
            batch_size=32,
            epochs=50,
            callbacks=[
                tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
            ],
            verbose='auto'
        )

        return model


    def category_case_basic_flow(self):
        conv_base = self.choose_convolutional_model()

        model = dynamic_spatial_module(conv_base, self.problem_case)
        model.summary()

        model.compile(
            # optimizer='adam',
            optimizer = tf.keras.optimizers.RMSprop(
                learning_rate=1e-5,
                # learning_rate=0.001, rho=0.9, epsilon=None, decay=0.0
            ),
            loss='sparse_categorical_crossentropy',
            metrics=['accuracy']
        )

        model.fit(
            x=self.x_train,
            y=self.y_train,
            batch_size=32,
            epochs=50,
            callbacks=[
                tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
            ],
            verbose='auto'
        )
        y_pred = model.predict(self.x_test).argmax(axis=1)

        return y_pred


    def transfer_flow(self):
        conv_base = self.choose_convolutional_model()

        model = dynamic_spatial_module(conv_base, self.problem_case)
        model.summary()

        # Pre trained
        if self.problem_case == CaseLabel.BINARY:
            model.compile(
                # optimizer='adam',
                optimizer = tf.keras.optimizers.RMSprop(
                    learning_rate=1e-5,
                    # learning_rate=0.001, rho=0.9, epsilon=None, decay=0.0
                ),
                loss='binary_crossentropy',
                metrics=[
                    tf.keras.metrics.BinaryAccuracy(name='accuracy'),
                    tf.keras.metrics.Precision(name='precision'),
                    tf.keras.metrics.Recall(name='recall'),
                ]
            )

            model.fit(
                x=self.x_train,
                y=self.y_train,
                batch_size=32,
                epochs=50,
                callbacks=[
                    tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
                ],
                verbose='auto'
            )
        elif self.problem_case == CaseLabel.CATEGORY:
            model.compile(
                # optimizer='adam',
                optimizer = tf.keras.optimizers.RMSprop(
                    learning_rate=1e-5,
                    # learning_rate=0.001, rho=0.9, epsilon=None, decay=0.0
                ),
                loss='sparse_categorical_crossentropy',
                metrics=['accuracy']
            )

            model.fit(
                x=self.x_train,
                y=self.y_train,
                batch_size=32,
                epochs=50,
                callbacks=[
                    tf.keras.callbacks.EarlyStopping(monitor='loss', patience=3)
                ],
                verbose='auto'
            )
        else:
            raise NotImplementedError
    
        base_model = Model(model.input, model.layers[-5].output)
        base_model.summary()

        bf_train = base_model.predict(self.x_train)
        bf_train = bf_train.reshape(bf_train.shape[0], -1)
        bf_test = base_model.predict(self.x_test)
        bf_test = bf_test.reshape(bf_test.shape[0], -1)
        print("\nBottleneck Features:\nbf_train: {}\nbf_test: {}\n".format(bf_train.shape, bf_test.shape))

        del base_model
        return bf_train, bf_test

