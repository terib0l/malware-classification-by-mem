import numpy as np
import umap
from model.base import BaseModel
from sklearn.metrics import classification_report

class SupervisedUMAP(BaseModel):
    def __init__(
        self,
        x_train,
        y_train,
        x_test,
        y_test,
        parse_args,
    ):
        super().__init__(
            x_train, y_train, x_test, parse_args
        )
        self.y_test=y_test


    def transfer_flow(self):
        """
        Parameter Explore
            - n_components: (4, 5, 10, 25, 50, 100)
            - min_dist: [0.15:1:0.05]
            - n_neighbors: [5:100:5]
            - metric: (Euclidean, Manhattan, Chebyshev, Cosine, Jaccard, Dice)
        """
        print("""
                Applied UMAP
        """)
        base_model = self.choose_convolutional_model()

        bf_train = base_model.predict(self.x_train)
        bf_train = bf_train.reshape(bf_train.shape[0], -1)
        bf_test = base_model.predict(self.x_test)
        bf_test = bf_test.reshape(bf_test.shape[0], -1)
        print("\nBottleneck Features:\nbf_train: {}\nbf_test: {}\n".format(bf_train.shape, bf_test.shape))

        for metric in ["manhattan", "euclidean", "chebyshev", "cosine", "jaccard", "dice"]:
            for n_components in (4, 5, 10, 25, 50, 100):
                # for min_dist in [
                #         0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6,
                #         0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0
                #     ]:
                for min_dist in np.arange(0.15, 1.0, 0.05):
                    for n_neighbors in range(5, 100, 5):
                        print(metric, n_components, min_dist, n_neighbors)
                        # _umap = umap.UMAP(
                        #     n_components=n_components, # 4
                        #     min_dist=min_dist,         # 1
                        #     n_neighbors=n_neighbors,   # 55
                        #     metric=metric,             # manhattan
                        #     random_state=4,
                        # )

                        # BF_train = _umap.fit_transform(X=bf_train, y=self.y_train)
                        # BF_test = _umap.transform(X=bf_test)
                        # print(
                        #     "\nBottleneck Features applied UMAP:\n"
                        #     "bf_train: {}\nbf_test: {}\n".format(
                        #         BF_train.shape, BF_test.shape
                        #     )
                        # )
                        for classify_func in [
                            "svc", "svm", "rf", "xgboost", "knn", "j48"
                        ]:
                            self.classify_func = classify_func
                            clf = self.choose_ml_classifier()
                            print(clf.__dict__)
                            # clf.fit(BF_train, self.y_train)
                            # y_pred = clf.predict(BF_test)
                            del clf
                            # print(classification_report(self.y_test, y_pred, target_names=['Benign', 'Malware'], digits=4))

