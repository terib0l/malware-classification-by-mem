import argparse
from sklearn.metrics import classification_report
from module.dataset import DumpwarePreparation
from module.metrix import output_metrix_from_matrix
from module.schema import (
    CaseLabel,
    PretrainedModel,
    ClassifyModel,
    # Attention
)
from model.plane import PlainModel
from model.ex_umap import SupervisedUMAP

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(dest='case')
binary_case = subparsers.add_parser('binary')
binary_case.add_argument('fold', nargs="?", type=int, default=1, choices=[1, 2, 3])
binary_case.add_argument('umap', type=bool, default=False)
category_case = subparsers.add_parser('category')

parser.add_argument("-m", nargs="?", type=str, default="vgg16", choices=[ e.value for e in PretrainedModel ])
parser.add_argument("-c", nargs="?", type=str, default="fcn", choices=[ e.value for e in ClassifyModel ])
# parser.add_argument("-a", nargs="?", type=str, default=None, choices=[ e.value for e in Attention ])

parse_args = parser.parse_args()

dataset = DumpwarePreparation(
    # data_dir=[
    #     '/content/4096/300/TRAIN/',
    #     '/content/4096/300/TEST/'
    # ],
    case_label=parse_args.case,
    model_name=parse_args.m
)

if parse_args.case == CaseLabel.CATEGORY:
    x_train, x_test, y_train, y_test = dataset.prepare_dumpware10_for_category()
    print(
        x_train.shape,
        x_test.shape,
        y_train.shape,
        y_test.shape,
        sep='\n'
    )
    print(y_train[:10], y_test[:10])

    model = PlainModel(
        x_train=x_train,
        y_train=y_train,
        x_test=x_test,
        convolutional_model=parse_args.m,
        classify_func=parse_args.c,
        problem_case=parse_args.case
    )
    y_pred = model.flow_execute()
    output_metrix_from_matrix(y_test=y_test, y_pred=y_pred, labels_num=parse_args.n)

elif parse_args.case == CaseLabel.BINARY:
    x_train, x_test, y_train, y_test = dataset.prepare_dumpware10_for_binary(parse_args.fold)
    print(
        x_train.shape,
        x_test.shape,
        y_test[:10],
        y_train.shape,
        y_test.shape,
        y_test[:10],
        sep='\n'
    )

    model = PlainModel(
        x_train=x_train,
        y_train=y_train,
        x_test=x_test,
        convolutional_model=parse_args.m,
        classify_func=parse_args.c,
        problem_case=parse_args.case
    )

    if parse_args.c == "fcn":
        trained_model = model.flow_execute()
        result = trained_model.evaluate(x_test, y_test, batch_size=32, verbose=0)
        for name, value in zip(trained_model.metrics_names, result):
            print(name, ': ', value)
        f1_score = 2*result[2]*result[3] / (result[2]+result[3])
        print('f1-score: ', f1_score)

    else:  # svm, rf, knn, j48, xgboost
        print(f"{parse_args.umap:^#20}")
        if parse_args.umap:
            model = SupervisedUMAP(
                x_train=x_train,
                y_train=y_train,
                x_test=x_test,
                convolutional_model=parse_args.m,
                classify_func=parse_args.c,
                problem_case=parse_args.case
            )
        y_pred = model.flow_execute()
        print(classification_report(y_test, y_pred, target_names=['Benign', 'Malware']))

else:
    raise NotImplementedError
